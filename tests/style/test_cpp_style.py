import os
import sys
import unittest
import glob
import copy

import cpplint_exceptions
import cpplint

def glob_maus_root_dir(glob_string):
    """
    @brief return glob relative to maus_root_dir

    @params glob_string file name or directory relative to maus_root_dir, with wildcards where appropriate

    @returns list of paths matching glob string, relative to maus_root_dir
    """
    here = os.getcwd()
    os.chdir(maus_root_dir)
    globs = glob.glob(glob_string)
    os.chdir(here)
    return globs

def walker(maus_root_dir, exclude_dirs, exclude_files):
    """
    @brief walk up from maus_root_dir and run cpplint

    @params maus_root_dir start walking from here
    @params exclude_dirs list of directory paths relative to maus_root_dir that should be excluded from the walk (hence recursive)
    @params exclude_files list of file paths relative to maus_root_dir that should be excluded from cpplint

    @returns number of errors found by cpplint
    """
    errors = 0
    for root_dir, ls_dirs, ls_files in os.walk(maus_root_dir):
        maus_dir = root_dir[len(maus_root_dir)+1:] #root_dir relative to maus
        path_exclude(exclude_dirs, maus_dir, ls_dirs)
        path_exclude(exclude_files, maus_dir, ls_files)
        errors += run_cpplint(root_dir, ls_files)
    return errors

def path_exclude(exclude_paths, path_root, path_list):
    """
    @brief Remove paths from path_list that are found in exclude_paths

    @params exclude_paths list of paths to exclude (paths relative to MAUS_ROOT_DIR)
    @params path_root suffix to add to path_list using os.path.join
    @params path_list list of paths to check for exclusions and modify

    @returns reference to ls_dirs
    """
    i = 0
    while i < len(path_list): #loop over all elements in list that is changing length
        if os.path.join(path_root, path_list[i]) in exclude_paths:
            del(path_list[i])
        else:
            i += 1

cpplint_suffixes = ['.hh', '.h', '.cpp', '.cc']    
def run_cpplint(root_dir, file_list):
    """
    @brief Run cpplint style checking script against a list of files

    @params root_dir path at which files can be found
    @params file_list list of files to run against cpplint

    @returns number of errors found

    Note that this only runs against files with suffixes in the list:
    """
    cpplint._cpplint_state.ResetErrorCounts()
    for a_file in file_list:
        target = os.path.join(root_dir, a_file)
        for suffix in cpplint_suffixes:
            if target.endswith(suffix):
                cpplint.ProcessFile(target, 3)
    return cpplint._cpplint_state.error_count
run_cpplint.__doc__ += str(cpplint_suffixes)


class cpplint_postprocessor:
    """
    @class cpplint_postprocessor
    cpplint_postprocessor is really just a collection of functions associated
    with postprocessing the cpplint file - i.e. subtracting known errors that
    should pass cpplint.
    """
    def __init__(self):
        """Does nothing"""
        pass

    def get_line_numbers(self, cpplint_output_filename):
        """
        @brief Read cpplint output file
        
        @params cpplint_output_filename the cpplint output to postprocess
        
        @returns a dict like {filename:[cpplint_error, line_number, '']
        """
        file_to_error = {}
        filename = os.path.join(maus_root_dir, cpplint_output_filename)
        fh = open(filename)
        lines = fh.readlines()
        for line in lines:
            line = line.rstrip('\n')
            words = line.split(' ')
            if words[0] != 'Done' and words[0] != 'Ignoring' and words[0] != 'File':
                file_path = words[0][0:-1] #words[0] = file_path:line_number:
                line_number = int(file_path[file_path.rfind(':')+1:])
                file_path = file_path[len(maus_root_dir)+1:file_path.rfind(':')]
                if file_path not in file_to_error: file_to_error[file_path] = []
                file_to_error[file_path].append([line, line_number, ''])
        return file_to_error

    def get_line_strings(self, file_to_error):
        """
        @brief Find lines of source code corresponding to a given error message

        @params file_to_error a dict like 
                            {filename:[cpplint_error, line_number, '']}
                    typically generated by get_line_numbers

        @returns a dict like {filename:[cpplint_error, line_number, line_text]}
        """
        for key in file_to_error.keys():
            fh_out = open(os.path.join(maus_root_dir, key))
            lines = fh_out.readlines()
            for i,value in enumerate(file_to_error[key]):
                if value[1]-1 >= 0: #line 0 can sometimes be error
                    file_to_error[key][i][2] = lines[value[1]-1].rstrip('\n')
        return file_to_error

    def print_error(self, file_to_error, fh=sys.stdout):
        """
        @brief Print formatted output

        @params file_to_error dict like {filename:[cpplint_error, line_number, line_text]}
        @params fh filehandle to which we write
        """
        for f,key in file_to_error.iteritems():
            print >>fh,'File',f
            for line in key: print >>fh,'   ',line[0]

    def compare_strings(self, test_dict, ref_dict):
        n_errors = 0
        for key,test_item in test_dict.iteritems():
            if key in ref_dict:
                for i,[error, line_number, line] in enumerate(test_item):
                    if line in ref_dict[key]:
                        del test_item[i]
            else:
                n_errors += len(test_item)
        return n_errors

    def process(self, cpplint_output_filename, cpplint_exceptions, processed_output_filename=None):
        """
        @brief Parse the cpplint output and check for exceptions

        @params cpplint_output_filename go through the cpplint output in this file and look for exceptions
        @params cpplint_exceptions list of exceptions for the cpplint output
        @params processed_output_filename if not set to None, output will be written to this file

        @returns integer corresponding to the number of errors that were not in the exceptions list
        """
        file_to_error = self.get_line_numbers(cpplint_output_filename)
        file_to_error = self.get_line_strings(file_to_error)
        if processed_output_filename != None:
            fh = open(processed_output_filename, 'w')
            self.print_error(file_to_error, fh)
            fh.close()
        return self.compare_strings(file_to_error, cpplint_exceptions)


class test_cpp_style(unittest.TestCase):
    """
    @brief Interface to unittest module
    """
    def test_glob_maus_root_dir(self):
        self.assertEqual(
            glob_maus_root_dir(os.path.join('tests', 'style', 'cpplint_tes*')),
            [os.path.join('tests', 'style', 'cpplint_test')])

    def test_walker_and_path_exclude(self):
        test_root_dir = os.path.join(maus_root_dir, 'tests', 'style')
        test_exclude_dirs = [os.path.join('cpplint_test', 'cpplint_test_exclude_dir')]
        test_exclude_files = [os.path.join('cpplint_test', 'force_fail.cc')]
        err_fh = open(os.devnull, 'w')
        sys.stderr = err_fh
        try: test_result = walker(test_root_dir, test_exclude_dirs, test_exclude_files)
        except: pass
        sys.stderr = sys.__stderr__
        err_fh.close()
        self.assertEqual(test_result, 3) #2 errors from force_fail_2.cc

    def test_cpplint_postprocessor(self):
        #First we make some errors
        fname = os.path.join(maus_root_dir,'tests','style','cpplint_test')
        err_fh = open(os.path.join(fname, 'test_cpplint.out'), 'w')
        sys.stderr = err_fh
        try: test_result = walker(fname, [], [])
        except: pass
        sys.stderr = sys.__stderr__
        err_fh.close()
        # now we try to postprocess
        test_exceptions = {'tests/style/cpplint_test/force_fail.cc':[
                '//No space at start - should fail',
                '//                                                                               more than 80 lines and space at end - should fail '
            ]
        }
        self.assertEqual(cpplint_postprocessor().process(os.path.join(fname, 'test_cpplint.out'), test_exceptions), 6)

    def test_cpp_style(self):
        """
        @brief Walk the directory structure and look for errors in cpplint
        """
        fname = os.path.join(maus_root_dir,'tmp','cpplint.out')
        err_fh = open(fname, 'w')
        sys.stderr = err_fh
        try: walker(maus_root_dir, exclude_dirs, exclude_files)
        except: pass
        sys.stderr = sys.__stderr__
        err_fh.close()
        test_result = cpplint_postprocessor().process(fname, cpplint_exceptions.exceptions, processed_output_filename=fname)
        self.assertEqual(test_result, 0,
            msg="Failed cpp style test - output in file:\n"+fname) 


maus_root_dir = os.environ['MAUS_ROOT_DIR']


exclude_dirs = [
'third_party',
'build',
'doc',
'.sconf_temp',
os.path.join('src', 'common'),
os.path.join('tests', 'cpp_unit'),
os.path.join('tests', 'style'),
os.path.join('src', 'common'),
os.path.join('src', 'map', 'MapCppTOFDigitization'),
os.path.join('src', 'map', 'MapCppTrackerDigitization'),
os.path.join('src', 'map', 'MapCppPrint')
]+glob_maus_root_dir(os.path.join('src', 'map', '*', 'build'))

exclude_files = [
]

if __name__=="__main__":
  unittest.main()

