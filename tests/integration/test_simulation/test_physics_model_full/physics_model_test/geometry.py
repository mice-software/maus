#  This file is part of MAUS: http://micewww.pp.rl.ac.uk/projects/maus
#
#  MAUS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  MAUS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with MAUS.  If not, see <http://www.gnu.org/licenses/>.

"""
Top level object for generating geometry files and running against different
codes
"""

import os
import subprocess
import xboa.Common as Common
from xboa.Bunch import Bunch

TEST_DIR = os.path.expandvars(
   '$MAUS_ROOT_DIR/tests/integration/test_simulation/test_physics_model_full'
)

def temp(file_name):
    """Prefix to temporary directory"""
    tmp_dir = \
           os.path.expandvars('$MAUS_ROOT_DIR/tmp/test_physics_model_full/')
    if not os.path.exists(tmp_dir):
        os.mkdir(tmp_dir)
    if not os.path.isdir(tmp_dir):
        raise OSError("test_factory area "+tmp_dir+" is not a directory")
    return os.path.join(tmp_dir, file_name)

def source(file_name):
    """Prefix to source files directory"""
    return os.path.join(TEST_DIR, 'files', file_name)

def ref_data(file_name):
    """Prefix to reference data directory"""
    return os.path.join(TEST_DIR, 'ref_data', file_name)

class Geometry:
    """
    Geometry object knows enough to run any monte carlo/whatever code that are 
    generated by that geometry and parse the output to create a Bunch used for 
    tests. Geometries are stored as a set of text files that drive the
    application and a list of text substitutions that are applied to the text
    files. The substitutions are there to allow easier manipulation of families
    of geometries, e.g. where we have one common text file with a few words 
    changed each time.

    I've set it up so that eval(repr(geometry) ) really does do a copy of the 
    geometry and tests. I thought this would be useful - this way you can do 
    repr(geometry) to write out the geometry and all tests and reference data. 
    Then eval() will recover all tests and reference data. You can see that the 
    code to actually run a test is pretty minimal (there is an example at the 
    end of this file). The downside is that the eval(string) step is hard to 
    debug.

      name         = human-readable string name used to identify the geometry
                     should be in form <code>_<code_version>:
                     <geoemtry unique ID>
      code_model   = tuple of (system_call used to run the code; list of command 
                     line arguments; dict of file_in:file_out files required for 
                     substitution)
      subsitutions = set of substitutions to make into input files to define the 
                     accelerator geometry
      bunch_read   = tuple of arguments to Bunch.new_dict_from_read_builtin(...) 
                     to load bunches used for tests; typically tuple like 
                     (file_type, file_name)
      bunch_index  = index of output bunch used for all tests
      tests        = list of tests that will be run against the bunch
    """
    def __init__(self):
        """Initialise the geometry"""
        self.name           = ''
        self.code_model     = ('', [], {})
        self.substitutions  = {}
        self.bunch_index    = 0
        self.bunch_read     = ('', '')
        self.tests          = []

    def __repr__(self):
        """
        Write out the geometry object. You should really be able to do 
        geometry_object == eval(repr(geometry_object)).
        """
        return 'Geometry.new('+repr(self.name)+','+repr(self.code_model)+','+\
                repr(self.substitutions)+','+repr(self.bunch_index)+','+\
                repr(self.bunch_read)+','+repr(self.tests)+')'

    def __str__(self):
        """
        Write out a summary of geometry object information.
        """
        out = str(self.name)+'\n'
        for test in self.tests:
            out += str(test)+'\n'
        return out

    def new(name, code_model, substitutions, bunch_index, bunch_read, tests): # pylint: disable = R0913, C0301
        """
        Initialise the object
        """
        my_geo = Geometry()
        my_geo.name          = name
        my_geo.code_model    = code_model
        my_geo.substitutions = substitutions
        my_geo.bunch_index   = bunch_index
        my_geo.bunch_read    = bunch_read
        my_geo.tests         = tests
        return my_geo
    new = staticmethod(new)

    def deepcopy(self):
        """
        Return a copy of the object
        """
        return Geometry.new(self.name, self.code_model, self.substitutions, 
                            self.bunch_index, self.bunch_read, self.tests)


    def read_bunch(self):
        """
        Read the input file
        """
        print self.bunch_read
        return Bunch.new_dict_from_read_builtin(*self.bunch_read)\
                                                              [self.bunch_index]

    def run_mc(self):
        """
        Set-up auxiliary files and run executable
        """
        here = os.getcwd()
        try:
            os.chdir(temp('./'))
            (executable, command_line_args, substitution_files) = \
                                                                 self.code_model
            print self.code_model
            for fin, fout in substitution_files.iteritems():
                Common.substitute(fin, fout, self.substitutions)
            proc = subprocess.Popen([executable]+command_line_args)
            proc.wait() # pylint: disable = E1101
        finally:
            os.chdir(here)


    def run_tests(self):
        """
        Run all the tests associated with this geometry
        """
        (passes, fails, warns) = (0, 0, 0)
        self.run_mc()
        test_bunch = self.read_bunch()
        for i, test in enumerate(self.tests):
            test_out = test.run_test(test_bunch)
            if   test_out.test_result() == 'pass':
                passes += 1
            elif test_out.test_result() == 'fail':
                fails  += 1
            else:
                warns  += 1
            self.tests[i] = test_out
        print self
        return (passes, fails, warns)

