#!/usr/bin/env python

# This file is part of MAUS: http://micewww.pp.rl.ac.uk/projects/maus
#
# MAUS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MAUS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MAUS.  If not, see <http://www.gnu.org/licenses/>.
#

import copy
import xboa
import numpy

from emittance_analysis import muon_mass

variable_list = [ 'x', 'px', 'y', 'py', 'z', 'pz' ]



def emittance_from_matrix( matrix, mass = None ) :
  """
    Calculate the emittance from a 2D covariance matrix. Requires the matrix to be square
    and have dimension 2nx2n for integer n.

    If no mass is provided, the muon mass is used by default.
  """
  if mass is None :
    mass = muon_mass
  if ( len( matrix ) % 2.0 ) != 0.0 :
    raise ArithmeticError( 'A Matrix with even numbers of rows and columns is Required to calculate an Emittance.' )

  if isinstance( matrix, numpy.matrix ) :
    shape = matrix.shape
    if ( shape[0] != shape[1] ) :
      print len( matrix ), len( matrix[0] ), map( len, matrix )
      raise ArithmeticError( 'A 2D Square Matrix is Required to calculate an Emittance.' )

  elif len( matrix ) != len( matrix[0] ) :
    print len( matrix ), len( matrix[0] ), map( len, matrix )
    raise ArithmeticError( 'A 2D Square Matrix is Required to calculate an Emittance.' )

  dim = len( matrix )
  return ( numpy.linalg.det( matrix ) ** ( 1.0 / dim ) ) / mass



class covariance_matrix() :
  """
    Performs running calculations of a covariance matrix to allow for larger
    datasets to be analysed with a smaller memory footprint. Running sums and 
    totals are stored, to be combined when necessary to form the final
    covariance matrix.

    Uses the whole 6D phase space, however the user may request subsets.
  """

  def __init__( self ) :
    """
      Initialse the object
      Set counters to zero, and values to zero.
    """
    self.__numVars = len( variable_list )
    self.__mean_vector = numpy.zeros( self.__numVars )
    self.__product_matrix = numpy.zeros( ( self.__numVars, self.__numVars ) )
    self.__num_particles = 0



  def clear( self ) :
    """ 
      Set our two matrices to zeros.
      As if nothing had happened!
    """
    self.__mean_vector = numpy.zeros( self.__numVars )
    self.__product_matrix = numpy.zeros( ( self.__numVars, self.__numVars ) )
    self.__num_particles = 0

  def add_hit( self, hit ) :
    """
      Add a hit and extract the information into the class.
      Accepts both xboa type hits and the local emittance analysis type hits.
    """
    for row, rowvar in enumerate( variable_list ) :
      for col, colvar in enumerate( variable_list ) :
        self.__product_matrix[row][col] += hit.get( rowvar ) *\
                                           hit.get( colvar )

      self.__mean_vector[row] += hit.get( rowvar )

    self.__num_particles += 1


  def add_dict( self, dictionary ) :
    """
      Add a hit by specifying the individual components in the 6D phase space
      in a dictionary of form { 'x': x, 'y': y ... }

      All variables in the 'variable_list' list must be provided.
    """
    for key in variable_list.keys :
      if key not in dictionary.keys :
        raise KeyError( str( key ) + ' not found in supplied dictionary.' )

    for row, rowvar in enumerate( variable_list ) :
      for col, colvar in enumerate( variable_list ) :
        self.__product_matrix[row][col] += dictionary[ rowvar ] *\
                                           dictionary[ colvar ]

      self.__mean_vector[row] += dictionary[rowvar]

    self.__num_particles += 1


  def get_covariance_matrix( self, axes = [ 'x', 'px', 'y', 'py' ] ) :
    """
      Combines the vector and matrix to form the covariance matrix and returns
      it.
    """
    if self.__num_particles == 0 :
      raise ZeroDivisionError( 'No particles found. Cannot divide by zero.' )
    cov_matrix = numpy.empty( ( len( axes ), len( axes ) ) )

    for covrow, rowvar in enumerate( axes ) :
      row = -1
      for num, test in enumerate( variable_list ) :
        if rowvar == test :
          row = num
      for covcol, colvar in enumerate( axes ) :
        col = -1
        for num, test in enumerate( variable_list ) :
          if colvar == test :
            col = num
        cov_matrix[covrow][covcol] = ( self.__product_matrix[row][col] - \
          ( self.__mean_vector[row] * self.__mean_vector[col] ) /\
          self.__num_particles ) / self.__num_particles

    return cov_matrix


  def get_determinant( self, axes = [ 'x', 'px', 'y', 'py' ] ) :
    """ 
      Returns the determinant of the covariace matrix
    """
    return numpy.linalg.det( self.get_covariance_matrix( axes ) )


  def get_emittance( self, mass = None, axes = [ 'x', 'px', 'y', 'py' ] ) :
    """
      Calculates the emittance of covariance matrix.

      Requires an even number of axes to  be provided, defaults to 4D transverse emittance.

      Emittance calculated as:
      ( Det( Cov ) ** ( 1 / len( axes ) ) ) / mass
      """
    if len( axes ) % 2 != 0 :
      raise FloatingPointError( 'Must supply and even number of axes to calculate an emittance' )
    if mass == 0 :
      raise ZeroDivisionError( 'Cannot divide by a mass of zero.' )

    if mass is None :
      global muon_mass
      mass = muon_mass
    power = 1.0 / float( len( axes ) )
    return ( self.get_determinant()**power ) / mass



class correction_matrix :
  """
    Performs a running calculation of the correct matrix to the covariance 
    matrix using in the emittance calculations.

    Using a subset of the 6D phase space (i.e. x,px,y,py) makes it faster!

    Initialise and then throw pairs of recon & MC hits at the class and it 
    saves the information in an efficient way.

    Uses the assumption that a measured hit has paramerters m[i], that are 
    related to the physical parameters by:

    m_i = u_i + d_i

    where d is some error. Then the covariance matrix, V is an approximation, 
    with corrections R & C such that:

    V_{true} = V_{meas} - R^T - R - C

  """
  def __init__( self, variable_list = ['x', 'px', 'y', 'py' ] ) :
    """
      Initialise the class. Sets counters and values all to zero.

      Records the full 6D phase space. Users can request a subset for most operations.
    """
    self.__vars = variable_list
    self.__counter = 0
    self.__length = len( variable_list )
    self.__R_products = numpy.zeros( ( self.__length, self.__length ) )
    self.__C_products = numpy.zeros( ( self.__length, self.__length ) )
    self.__V_products = numpy.zeros( ( self.__length, self.__length ) )
    self.__d_vector = numpy.zeros( ( self.__length ) )
    self.__u_vector = numpy.zeros( ( self.__length ) )
    self.__m_vector = numpy.zeros( ( self.__length ) )

  def add_hit( self, recon, MC ) : 
    self.__counter += 1
    deltas = numpy.zeros( ( self.__length ) )

    for i in range( self.__length ) :
      deltas[i] = recon.get( self.__vars[i] ) - MC.get( self.__vars[i] )

    for i in range( self.__length ) :
      self.__d_vector[i] += deltas[i]
      self.__u_vector[i] += MC.get( self.__vars[i] )

    for i in range( self.__length ) :
      for j in range( self.__length ) :
        self.__R_products[i][j] += MC.get( self.__vars[i] ) * deltas[j]
        self.__C_products[i][j] += deltas[i] * deltas[j]


  def __len__( self ) :
    return self.__counter

  def number_hits( self ) :
    return self.__counter


  def get_R_matrix( self ) :
    """
      Calculates the R Correction matrix given by:

      R_{ij} = cov( u_i, d_j )
    """
    R = numpy.zeros( ( self.__length, self.__length ) )

    for i in range( self.__length ) :
      for j in range( self.__length ) :
        R[i][j] = ( self.__R_products[i][j] / float( self.__counter ) ) - \
          ( ( self.__u_vector[i] * self.__d_vector[j] ) / \
          float( self.__counter ** 2 ) )

    return R

  def get_C_matrix( self ) :
    """
      Calculates the C Correction matrix given by:

      C_{ij} = cov( d_i, d_j )
    """
    C = numpy.zeros( ( self.__length, self.__length ) )

    for i in range( self.__length ) :
      for j in range( self.__length ) :
        C[i][j] = ( self.__C_products[i][j] / float( self.__counter ) ) -\
          ( ( self.__d_vector[i] * self.__d_vector[j] ) / \
          float( self.__counter ** 2 ) )

    return C

  def get_full_correction( self, axes = [ 'x', 'px', 'y', 'py' ] ) :
    """ 
      Returns the full correction matrix to be added to the covariance matrix
    """
    if not self.check_axes( axes ) :
      raise KeyError( "Axis list is not a subset of the class axis list" )
    R = self.get_R_matrix()
    C = self.get_C_matrix()
    Rt = numpy.matrix.transpose( R )

    new_matrix = -R - Rt - C
    return new_matrix


  def correct_covariance( self, cov_mat, axes = [ 'x', 'px', 'y', 'py' ] ) :
    """
      Calculate and apply the three correction matrices to the covariance 
      matrix.
    """
    correction = self.get_full_correction( axes )

    new_cov = copy.deepcopy( cov_mat ) + correction

    return new_cov
    

  def check_axes( self, axes ) :
    """ 
      See if the axes provided are a subset of the classes expected axis list.
      If not then we can't do any covariance matrix correcting.
    """
    for ax in axes :
      if ax not in self.__vars :
        return False
    return True


  def clear_all( self ) :
    """
      Resets all the data to zeros. As if nothing ever happened!
    """
    self.__R_products = numpy.zeros( ( self.__length, self.__length ) )
    self.__C_products = numpy.zeros( ( self.__length, self.__length ) )
    self.__d_vector = numpy.zeros( ( self.__length ) )
    self.__u_vector = numpy.zeros( ( self.__length ) )
    self.__counter = 0

  def save_R_matrix( self, filename ) :
    """
      Saves the R Matrix to a File to be used or examined later
    """
    numpy.savetxt( filename, self.get_R_matrix() )

  def save_C_matrix( self, filename ) :
    """ 
      Saves the C Matrix to a File to be used or examined later
    """
    numpy.savetxt( filename, self.get_C_matrix() )

  def save_full_correction( self, filename ) :
    """
      Saves the full correction matrix to a file to be used or examined later
    """
    numpy.savetxt( filename, self.get_full_correction() )




###############################################################################



class data_handler() :
  def __init__( self, filename ) :
    self.__filename = filename

    self.__p_value_cut = 0.05
    self.__pt_cut = 150.0
    self.__pz_cut = 300.0
    self.__pt_low_cut = 0.0
    self.__aperture_cut = 189.0
    self.__pid_cut = -13



