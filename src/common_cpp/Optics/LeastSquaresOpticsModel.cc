/* This file is part of MAUS: http://  micewww.pp.rl.ac.uk:8080/projects/maus
 *
 * MAUS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MAUS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MAUS.  If not, see <http://  www.gnu.org/licenses/>.
 */

/* Author: Chris Rogers (G4MICE)
 * Author: Peter Lane (MAUS update)
 */

#include "Optics/LeastSquaresTransferMapCalculator.hh"

#include <math.h>

#include <iomanip>
#include <sstream>
#include <vector>

#include "gsl/gsl_sf_gamma.h"

#include "Interface/Interpolator.hh"
#include "Interface/Mesh.hh"
#include "Interface/Squeal.hh"
#include "Maths/Matrix.hh"
#include "Maths/SymmetricMatrix.hh"
#include "Maths/Vector.hh"

namespace MAUS {

void LeastSquaresOpticsModel::Build(const Json::Value & configuration) {
  // Determine which fitting algorithm to use
  SetupAlgorithm(configuration);

  // Build a set of test hits that will be pushed
  // through the lattice to build transfer maps.
  BuildTestHits(configuration);

  // Push the test hits through the lattice generating
  // intermediate hits along the way.
  Simulate(configuration);

  // Create a set of transfer maps between the intermediate hits
  // generated by the simulation.
  CalculateTransferMaps(configuration);
}


void LeastSquaresOpticsModel::SetupAlgorithm(const Json::Value & configuration) {
  Json::Value algorithm_names = JsonWrapper::GetProperty(
      configuration,
      "LeastSquaresOpticsModel_algorithmS",
      JsonWrapper::arrayValue);
  Json::Value algorithm_name = JsonWrapper::GetProperty(
      configuration,
      "LeastSquaresOpticsModel_algorithm",
      JsonWrapper::stringValue);
  size_t algorithm;
  for (algorithm = 0; algorithm < algorithm_names.size(); ++algorithm) {
    if (algorithm_name == oalgorithm_names[model]) {
      break;  // leave the current index into opalgorithm_names in algorithm
    }
  }
  algorithm_ = Algorithm(algorithm);
}

void LeastSquaresOpticsModel::BuildTestHits(const Json::Value & configuration) {
  // TODO(plane1@hawk.iit.edu) Get the following from the configuration
  const PhaseSpaceVector reference_trajectory_in;
  const PhaseSpaceVector deltas;

  std::vector<double> reference_trajectory;
  for (size_t index = 0; index < 6; ++index) {
    reference_trajectory.push_back(reference_trajectory_in[index]);
  }

  test_hits.push_back(reference_trajectory);

  for(int coordinate_index = 0; coordinate_index < 6; ++coordinate_index)
  {
    std::vector<double> hit = reference_trajectory;

    hit[coordinate_index] += deltas[coordinate_index];
    test_hits.push_back(hit);

    hit[coordinate_index] -= 2. * deltas[coordinate_index];
    if ((coordinate_index == 1) && (hit[coordinate_index] < 0)) {
      hit[coordinate_index] *= -1.;
    }
    test_hits.push_back(hit);
  }

  return test_hits;
}

void LeastSquaresOpticsModel::Simulate(const Json::Value & configuration) {
}

void LeastSquaresOpticsModel::CalculateTransferMaps(const Json::Value & configuration) {
  // TODO(plane1@hawk.iit.edu) create a polynomial map for each intermediate
  // hit created in the simulation to the next

  // TODO(plane1@hawk.iit.edu) get the following from the configuration
  const size_t polynomial_order = 3;
  const std::vector<double> weights;
  const PhaseSpaceVector reference_trajectory_in(0, mass, 0, 0, 0, 0);
  const PhasespaceVector deltas(1, 1, 1, 1, 1, 1);

  // Create test particle hits used to determine the transfer map
  const std::vector< std::vector<double> > test_hits
    = BuildStartHits(reference_trajectory, deltas);
  
  const std::vector< std::vector<double> >& end_hits;

  PolynomialMap * polynomial_map = NULL;

  if (algorithm_ == Algorithm::kNone) {
      throw(Squeal(Squeal::nonRecoverable,
                   "No fitting algorithm specified in configuration",
                   "LeastSquaresOpticsModel::GenerateTransferMap()"));
  } else if (algorithm_ == Algorithm::kUnconstrainedPolynomial) {
    // unconstrained polynomial
    polynomial_map = PolynomialMap::PolynomialLeastSquaresFit(
        start_coordinates, end_coordinates, polynomial_order, weights);
  } else if (algorithm_ == Algorithm::kConstrainedPolynomial) {
    // constrained polynomial
    // ConstrainedPolynomialLeastSquaresFit(...);
    throw(Squeal(Squeal::nonRecoverable,
                  "Constrained Polynomial fitting algorithm "
                  "is not yet implemented.",
                  "LeastSquaresOpticsModel::GenerateTransferMap()"));
  } else if (algorithm_ == Algorithm::kConstrainedChiSquared) {
    // constrained chi squared
    // Chi2ConstrainedLeastSquaresFit(...);
    throw(Squeal(Squeal::nonRecoverable,
                  "Constrained Chi Squared fitting algorithm "
                  "is not yet implemented.",
                  "LeastSquaresOpticsModel::GenerateTransferMap()"));
  } else if (algorithm_ == Algorithm::kSweepingChiSquared) {
    // sweeping chi squared
    // Chi2SweepingLeastSquaresFit(...);
    throw(Squeal(Squeal::nonRecoverable,
                  "Sweeping Chi Squared fitting algorithm "
                  "is not yet implemented.",
                  "LeastSquaresOpticsModel::GenerateTransferMap()"));
  } else if (algorithm_ == Algorithm::kSweepingChiSquaredWithVariableWalls) {
    // sweeping chi squared with variable walls
    // Chi2SweepingLeastSquaresFitVariableWalls(...);
    throw(Squeal(Squeal::nonRecoverable,
                  "Sweeping Chi Squared Variable Walls fitting algorithm "
                  "is not yet implemented.",
                  "LeastSquaresOpticsModel::GenerateTransferMap()"));
  } else {
    throw(Squeal(Squeal::nonRecoverable,
                  "Unrecognized fitting algorithm in configuration.",
                  "LeastSquaresOpticsModel::GenerateTransferMap()"));
  }

  TransferMap * transfer_map = new PolynomialTransferMap(
    *polynomial_map, reference_trajectory);
  delete polynomial_map;
}

TransferMap * LeastSquaresOpticsModel::GenerateTransferMap(
    double start_plane, double end_plane, double mass) const {
  TransferMap * transfer_map = NULL;

  /* TODO(plane1@hawk.iit.edu)
   *  1) Find the map that starts closest to start_plane
   *  2) Find the map right before the one that starts closest to end_plane
   *  3) Multiply all maps together in reverse order between and including
   *     the maps in 1) and 2)
   *  4) Create a PolynomialTransferMap using the map product
   */

  return transfer_map;
}

    /*
  static PolynomialMap* PolynomialLeastSquaresFit(
    const std::vector< std::vector<double> >& points,
    const std::vector< std::vector<double> >& values,
    unsigned int                                        polynomialOrder,
    const VectorMap*                          weightFunction);

  static PolynomialMap* PolynomialLeastSquaresFit(
    const std::vector< std::vector<double> >& points,
    const std::vector< std::vector<double> >& values,
    unsigned int                                        polynomialOrder,
    const std::vector<double>& weights = std::vector<double>());

  static PolynomialMap* ConstrainedPolynomialLeastSquaresFit
      (const std::vector< std::vector<double> >&  points,
       const std::vector< std::vector<double> >& values,
       unsigned int polynomialOrder,
       std::vector< PolynomialCoefficient > coeffs,
       const std::vector<double>& weights = std::vector<double>());

  static PolynomialMap* Chi2ConstrainedLeastSquaresFit
      (const std::vector< std::vector<double> >&  xin,
       const std::vector< std::vector<double> >& xout,
       unsigned int polynomialOrder,
       std::vector< PolynomialMap::PolynomialCoefficient > coeffs,
       double chi2Start, double discardStep, double* chi2End, double chi2Limit,
       std::vector<double> weights, bool firstIsMean = false);

  static PolynomialMap* Chi2SweepingLeastSquaresFit
      (const VectorMap& vec, unsigned int polynomialOrder,
       std::vector< PolynomialMap::PolynomialCoefficient > coeffs,
       double chi2Max, std::vector<double>& delta, double deltaFactor,
       int maxNumberOfSteps);

  static PolynomialMap* Chi2SweepingLeastSquaresFitVariableWalls
      (const VectorMap& vec, unsigned int polynomialOrder,
       std::vector< PolynomialMap::PolynomialCoefficient > coeffs,
       double chi2Max, std::vector<double>& delta, double deltaFactor,
       int maxNumberOfSteps, std::vector<double> max_delta);

  double GetAvgChi2OfDifference(std::vector< std::vector<double> > in,
                                std::vector< std::vector<double> > out);
    int algorithm_id = algorithm_->id();
    switch {
      case 5: {  // sweeping chi squared with variable walls
        // Chi2SweepingLeastSquaresFitVariableWalls(...);
        break;
      }
      case 4: {  // sweeping chi squared
        // Chi2SweepingLeastSquaresFit(...);
        break;
      }
      case 3: {  // constrained chi squared
        // Chi2ConstrainedLeastSquaresFit(...);
        break;
      }
      case 2: {  // constrained polynomial
        // ConstrainedPolynomialLeastSquaresFit(...);
        break;
      }
      case 1:    // unconstrained polynomial
      default: {
        // PolynomialLeastSquaresFit(...);
      }
    }
  }
*/
 
}  // namespace MAUS
